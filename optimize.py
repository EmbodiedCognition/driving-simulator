#!/usr/bin/env python

import collections
import joblib
import lmj.cli
import logging
import numpy as np
import scipy.optimize as SO
import StringIO

import main

# this is a histogram of raw human subject data from sullivan, johnson, ballard,
# and hayhoe (2012). the axes of this histogram are :
#
# 0 x4   condition
# 1 x16  subject
# 2 x101 look duration (binned in 0.3s increments)
# 3 x2   look target (speedo, leader)
HUMAN_LOOKS = np.load(StringIO.StringIO('x\x9c\xed\x9d\xbb\x8e\x1cE\x14\x86\x87\xcc"r\xe0\xc0\x01\xc1\xa8\x85v\rZ!\xdb\x18s3P\x80D\x80\x04"! B\x16\x18\x11 @6\x19B\xe2\x1dxQ\x1e\x01C\xd7?\xd2\xfcC\xfbtm\xf5LW\xf7|\x9f\x04Gg\xfaV\xbd\x9e=g\xab\xce\xa5\xfe\xfa\xf2\xeb/\xbe\xfa\xe6\xa5\xcdg\x9b\xdf/\xbf\x7f\xf2\xec\xbb\xa7\x97\xefm/\x1f\xfd\xf0\xce\xe5\xd5\xf6\xf2\x87_\x9e\xfe\xf6\xf4\xf1\xcf\xdf\xfe\xf2\xf4\xfb\'\xff~\xfe\xd9\xe3\x9f\x9e=y\xfe\xf9\xb3\x1f\x1f\xff\xfa\xe4\xb9~\xe7\xc1\xd5\xf6\xde\xc3\xe7\xff\xdd\xbdw\xb5\xbd\xff\xda\xd5\xf6\x8f\xed\xcb\x9b=\xfe\xfe\xa8\x97\xaf\xa7^\xde\xccr\xe3\xfaf\xff\xf3!]\xf7\x1b\xd2\x9d\x83\xe3\xc1\xfdj\xa9\x1e\x1f\xecQ\xfa\xf3)\xfd\xf9\xb7\xce\xd2\xc7\x0f0)\xa9\x17\xb7\xd3\xbe\xee\xc7\xa3\xebE\xe4\x1f\x9cZ\xfbr\xf2\xdf\xe7Twy\xf4\xbe\xd8\xa7\x17\xd3\xfc\xf7\x03\xe0\x8c\xc9~\xe4\xcf\xd4\xcb\xcd\xfd\xb4\xf7\xf9\xe6N\x96\xb2\xa3\x17Y\xde\xb4\xf3v\x98~#\xeb\xbb\xdfk?\xdf\xa8\xfd\xfd\xc7~\x00\x00\xcc\xcb;\xa9\x97\xf2\x1f\xaf\x98.\xff\xb1M\xfb\xd7\xc9\x9f\xc8\x8e\xdf4\xfd\x86\x9d\x7f\x80\x1d?\xf6\xfaSk\xfe\xa6\xb5\xf1\x00\x00\xd42\xd6\xae\x85\xe7\xa5\xeb\xddw,\xc5\xf7K\x95\xf7\x0b\xae\x0f\xefW\xf9\xfcc\xfb\x9b\xb5\xf9g\x00\x98\x9f\xb1\xebQ\x83\xd7\x9d\x88\xa9\xed\xdf\xd4\xf1\xe4S\xc7C\xe6\x8e\xbf\xcc\xedO\xe6~~D\xeb\xe3\x038\x06Z\xdf\x92\xec\xb2\xbc\x95\xe5n\xdd*K\xf7?\xd2K\xf3\xb5\x8a\xed\xb1\xdd\xef\x80\xe8\xb8q\xea\xfc\xb2\xdax>\x00@\xabx\xdcC\xf1\x90WM\x97?\xb9e\xd2\xfd\xc8A\xbc$\xed\xcb\xa9\xf3s\x9a\xff\xfb/\xcd=\x80\x89Is\x0f\x00\x00\x9a#\xf5B\xf6\xffQ\x96\x9a\x9f\xc8_ti\xff|\xe5w\xf9}\xc4-\xd3\xdd\xbf\xb8\x1e\xcdG\xa2\xf3\x0fH\xc1\xf1\x80\xe6\xfd\x13\x00@cx\x1e\xd6\xfbY\xdf\xda\xe7od\xdd\xfd\x8f\xf0|a\xbf\xafS\x1dO7\xbd\xf5z\x84\xb5\xfb\xa7\xb5\xbf\x1f\x00\xc4\xb8_\xf8@\xba\xc9W\xec<\xd7\xbd~\xde\xfdK\xe9|\xe5\xa0\x1e\xdf\x98\xdb~\xcd\xfd|\x00\x80\xe6H\xfb\xea\xc3\xac\xab\x9eQ\xf3\x94\xb7\xb3\xbc\x9b\xe5\r\x93>\x1f\x19\x9c\x9f\xd8\xf3D\xeb\xf3\x0b\x00\x00\x08H\xbd\xf08\xbb\xe6\x177\xed\xb8_\'\xdc\xbe\xfb\xfc$\x8a\x878\xa7\xce\xbf=u~\x00\xfep\xdd\xf0\xef\x0b\xe7\x8c\xec\xbb\xe7quY\xfa\xfaS8\xef0\xbd4\x9e^z\xbc4\x9e\x1fq\xec~bs\xd7\x8b\x00\x00\x1c\x1b\xcf\xff\xd5\xba\x97\xc7?\xbco\xe4\x90\xbf\x18\xdbo%\x8a\xaf\x1c\xbb\xberi\xf6\xbd\xf5\xf1\x01\xc0\x19\x93z\xa18\xbb\xe2$\xea\xdb\xe5\xf9^\xbe>&\xbc\xef\xa3\xfb\xa7\xb1\x0c\xd6E^\x13\xd6\x9f\x8e\x0b\xfdZ\x00@\xc8\x8f(\x1e\xdfe\xe9\xfb\xa2\xf8\xf9\xc2\xfbCF\xfb\xa5D\xc7O^\xaf^\xc8\xdc\xcf\x07\x00h\x15\xd5\xc1\xcbo\xbc\x99\xa5\xcfC\x06\xedh\xdaW\xc3xIz\xb1^\xdbor\xea\xf5+\xf2\xcf\x00\x00\xc6\xe1\xfd\xba\x147\x91]\xd4\xe7~\xfe\x8eHw\xecxq=|p\xff\xb9\xfb3N\xcd\xd2\xc6\x0b\x00\xe7\x8b\xe2\xebZ\xef\xf2}\x7f=~2T\x0f?\xa4\x97\xc6\xd7[\x8bw\xac->\xd0\xdax\x00`}\xf8\xbe\x8c\xf2\x0b>\x1f)\xed\xbfU\xbc\x1fp\xa4\x07\x14\xf7#\x8e\xb0\xeb\xd7\xe6_jY\xdb\xfb\x00@9n\x07\xaeR/\xbd/}\x94\xef\x1b\xc5\xd7K\xd7\xaf\xa6^\xaf\x9a\xdb\xfe\xb7no[\x1b\x1f\xf1*\x80\xe5"{\xaf\xfe]\x0f\xb2\xd4:W\x97\xa5\xe6)\xbe\xde\xe5\xf9]\xe1\xfaV\xa4G\xd8\xf9\xd8\x13\x00\x80FH\xbd\xf80\xcb{Y*\x8e\xe2\xfb\xc7\xcb\xafD\xf1\x94\xd1\xfd\x85Sp<\xba\x1e\x00\x00\x9a@\xf6y\x17\'qy\xa2\xe7\x1f\xebxHz\xf1\xfdZ\xf3_\xad\x8d\x87\xfd\xb5\xa6ei\xf9&\x00\xffr\xed>Wc\xcf\x1b\xf9\xdc\xd2\xf3\xd7\x1e\xcfp\x16\xf7\xbe\xe9\xc4\xcf[\x18K\xfb\xfe\xc1\xb2\x98\xeb\xfb\xb5{n\xfa\xef\xff\x7f~\xdc\xcb\xdd\xfa\xd6\xeb&Em}\xbc\xbfo\xd8o2`\xea\xf9\x0b\xbf\xef\x00\x00\xd7C\xf6S\xf1\xf8\xf7\xb2T\xdd\xbc\xfay\xdd6\xb9\xf3\x03\x03r\xb0\x0fW\xda\x8cc\xe0<\xfc\x03\x00@\x9b\xc8\xde~\x9ez\xa9:\x14\xd9s\xf5_\xd1ywL\xf7\xf9I\x94/\x1c\xcdG\xb0\xff\x00\x00\xcb\xc2\xed\xb6\xf2\xbb\xdc\xdew\xa6G\xf9\xc0~\xdc\xfb\x10;\xa5\xfb\xa3\x84\x04\xcf\xab\xed\xd7\xb26\xe6~\xbf\xb9\x9f\x0f\x00\x13\x90z\xa1\xf8\x88\xd6\xb7>\xcdR\xeb_]\x96od\xb9\xf3\x0fC2S\\\x07_\tv\t\x00`^\xe4O.\xb2|\x94e\x97\xa5\xef\xd7(?\xe0u&C\xebZc\xf7\xd5*\xf6\x07\x95\xf7[\x9b\xffY\xdb\xfb\x00\xc0\xf2\xb0<\xafp\xfd)\x8a\x7fD\xfd!\xa7\xde\xdfd\xea\xfd\x84\xa7\xa6z<i\xaa\x91\x00\x00\x9c\x16\xb7\xcf\xae{\xfc\xfdU\xd3=^\xd2\x99^\x1a\xaf\xaf\xad7\xe4\xefv\x00\x80\xd3 {.)\xff\xa0</\xf9\x0f\xcf\x17\xf6}}\xfd~\xc2\xfd\xc3A|\xdeu\xa3\xf5\xf8xk\xe3\x01\x00\x98\x1b\xdf\xf7d\xa8\xdf\xf0m\xd3\xa3~\xf6\xb5\xfb\xa1\x9c\xbc\xffcz\xf1\xe1\xd6\xfd\x1b\x00\xc0\\\xc8\x1e*\x1e/\x7f\xe1u\x8c\x07\xfed\xf3\xffz\xe4?J\xfb\xbc\x94\xf6\xaf_\xfb\xfa\xd7\xd2\xc7\x0f\x00\xebE\xf6\\\xf9\xc0\x9a\x97\xdc5]\xeb`\xde_x(\xfe\xee\xf5\xf1\x1e\xf7\x17c\xfd\xc3\xe8~\xc5\x95`\xaf\x01\x00\xcap;\xad\xbaw\xc57\xe4G\x14?\x91\x9f\xf0\xf9\xca`\xdf\x95\xcd\xfe\xf1\xb1\xf1\x16\xe7 >\x0f\x00\x00M\xe1\xf3\x8b.K\xad{\xdd\xb1\xcf%\xbd\x9eq\xb0\xce$\x99\xbe\xd9\xbf\x9ey@\x19\xfc\xbc\x00\xa0U\xb4o\x96\xc7E<\x7fkk\xba\xc7K\xa2x|\x94\x1f\\\x1a_\x99\xbb^cn\xbb>\xf7\xf3\x01\x00\x1c\xd9i\xcd\x17\xa4_\x98\xee\xf5%\xae{?{\xafOq\x7f3\xf9\xfe\xbf\x00\x000+\xbe>%?\xe2}\xea\xa5k^\xa2\xb8\x8a\xf0xH\x94\xdf\xe5\xe7\xaf=\x1f\x0b\x00\xe0lH\xbdP\xbcD\xf3\x8b\xb7\xb2\xd4\xba\x98\xe6\x19Q=\xe3P<^\x94\xfa\x8fk\xef\x9f2\x12\xfc\x15\x00\xc0\xb4h\x9f\x13\xcd\'\x86\xf2}K\xfb\xa3\x84\xf5\x8b\x91n\x94\xfa\x97\xd6\xf2\x89[\xf3_\xad\x8d\x07\x00\x96\x87\xd7\x83h>\xd2e\xa9u.\xad\x83\xe9<\xcf\xef*]\xbfr<\xbe_\xdb\xaf\xab\x18\x7f\xfe\x99\x83\x7f\x01\x80k\x93z\xe1qx\xaf3\x19\xaa+\x8c\xe2\xed\xa5\xfd\x84\x8b\xd7\xb7J\xef73\xc7\x1e_k\xef\x0b\x00\xe7\x83\xfc\x81\xea\xe3\xe5W\xee\x99<\xa8\x87\xcf\xd2\xe7\x17\xc5\xf9\xbc\xae\x07,\xae\xdf<\x00\xc0\x99\xa0\xf5\xaaw\xb3\xdc\xe5\xfbf\xe9\xf3\x8f\xce\xf4\xa8\x9e$\xaao\xaf\xed\xcfU\xfb\xf7\xfe\xd4\xd7\x03\x00\x9c+\x9a_h\x1e\xe2\xfd\xe9\xbd\x9e\xd1\xebK\xa2~\xf4\x91\xbd\r\xfb\x0f\x07\xcc\xbd\xbe\xb56\x7f\xb2\xb6\xf7\x01\x80\xe3\xe3\xf1x\xef\'|\xcb\xa48\xc8\x0fv\xecxi\xbf\xe1\xe8~S\xc7K\xd6>\x1fY\xdax\x01`\xf9|\x92zya\xf2A\x96\xb2\xe3\x9d\xf4\xccP~\xd6\xe0\xbe\xf1\xa6/}\xbdi\xee\xe7\x03\x00\xb4\xc6\x90\xfd/\xed\xb75t_\x11\xc5Sj\xe7/\xd5\xf5\x92\x85\xf7\x9f\xba\x1e\x05\xff\x04\x00KE\xf6\xdb\xfb\xd1k]\xcb\xe3\'\xa5\xf1\r\'\xb2\x97\xa5\xfd$\xa3\xfbO\xee_\x82\xebK9\xf6\xf8\x00\x00\x8eN\xea\x85\xfc\xc6\xc3,\x1f\x98\xeeu)\xbe\x9f\xd6\x85\xe9\xd1|&\x82\xfc\\\x00\x80e!;\xef\xfb3*o\xd8\xfbCJ\xef\xb2\xf4}L|\xdf\x93\xe8\xb9;L\xe7\xefq\x00\x80e\xe3\xfd\xeb\x87\xf6\xf3-\xee\xbfezi\xff\xaf\xc9\xebO\xfcy\x01\xa7\xf6o\xe4;\x03\xc0\xd2\xf1\xbe\\;\x02\xbdt\xbf\xde\xda\xf8F\xc4\xd4\xf5\x8e\xb5\xcf;6k{\x9fZ\x966^\x805\xe0\xebT\x8a\xbb+>\xd2e\xe9\xfdU\xbc^\xbe\xb4\x7f\x97\x9f_\xbd\x1fc))<\xe3\xb8\xcf\x07\x00X)\xb2\x97\x8a\x9f\xf8\xbeY]\x96\xb2\xc3\xda\x8fqh=,\xec\xe7\x18\x9d?0\xbe\xeb^\xbfv\xce\xfd\xfd\x01\xa0=\x94\xd7\xe5\xf9[Q}{\xd4o\xa5\xb6\xbe\xfd\xd4\xfd\xbcj\xc1\xbe\xc3\x92\xe0\xfb\n\x93\x92z\xa1y\xc7P\xde\x96\xf7g\x11\xd1z\x95S\xfd\xfd\r\xee\x7fn\xd0\xef\xfe\xb8\xb4\x96\xbf\xce\xbf\x0f\xb4\x8c\xfc\x87\xf6\xd3R~\xb0\xef\xff\xeb\xf9\xc5c\xf3\xbfJ\xe3\xf1\xa7\xee\x0f\x1c\xdd\x0f\x00\x00\xc6\xa1x\xc9\xa7Y\xde\xcfR~Eq\x14\xd1\x99.\x7f1\xe8_\x02j\xfb\xb9\xd4\x82\xff\x00\x00\xb8.\xff\x00:\x0b\xdbw'.decode('zlib')))
CONDITIONS = ('follow', 'follow+noise', 'speed', 'speed+noise')


Args = collections.namedtuple(
    'Arguments',
    'control_rate fixation_rate trace lanes '
    'follow_threshold speed_threshold lane_threshold '
    'follow_step speed_step lane_step ')

def look_durations(**kwargs):
    '''Count up look durations from the simulator at these parameters.'''
    looks = [0], [0], [0]
    prev = 0
    duration = 0
    for metrics in main.Simulator(Args(60., 3, False, None, 1, **kwargs)):
        if not metrics: continue
        module = metrics[-1]
        if prev != module:
            looks[prev].append(duration)
            prev = module
            duration = 0
        duration += 1
    return looks[:2]


def kl(p, q):
    '''Compute KL divergence between distributions p and q.'''
    valid = p != 0  # 0 log 0 is 0, so we discard these elements of p.
    return (p[valid] * np.log(p[valid] / (q[valid] + 1e-4))).sum()


def abbrev(s):
    '''Return a string with abbreviated simulator-specific terms.'''
    for a, b in (('follow', 'f'), ('speed', 's'), ('lane', 'l'),
                 ('noise', 'n'), ('threshold', 't'), ('step', 's')):
        s = s.replace(a, b)
    return s


def compare(params, humans):
    '''Compare simulated look durations with human target look durations.'''
    if not all(p > 0 for p in params):
        return 10  # force all parameters to be positive.

    # partition parameters for experimental conditions.
    st_lo, st_hi, lt, fs_lo, fs_hi, ss_lo, ss_hi, ls = params
    def kwargs(cond):
        kw = dict(lane_threshold=lt, lane_step=ls)
        if 'noise' in cond:
            kw['follow_step'] = fs_hi
            kw['speed_step'] = ss_hi
        else:
            kw['follow_step'] = fs_lo
            kw['speed_step'] = ss_lo
        kw['speed_threshold'] = st_hi if 'speed' in cond else st_lo
        return kw

    # run simulations and compute simulated to human kl divergence.
    total_kl = 0
    bins = np.arange(humans.shape[1] + 1)
    for i, (speedo, leader) in enumerate(joblib.Parallel(n_jobs=4)(
            joblib.delayed(look_durations)(**kwargs(n)) for n in CONDITIONS)):
        cond = CONDITIONS[i]

        # concatenate and normalize look histogram from simulation.
        distro = np.concatenate([
            np.histogram(speedo, bins=bins)[0],
            np.histogram(leader, bins=bins)[0]]).astype(float)
        distro /= distro.sum()

        # concatenate and normalize look histogram from human data.
        target = np.concatenate([humans[i, :, 0], humans[i, :, 1]]).astype(float)
        target /= target.sum()

        # compute kl divergence between these two quantities.
        local_kl = kl(distro, target)

        p = ('%s=%.4f' % (abbrev(k), v) for k, v in sorted(kwargs(cond).iteritems()))
        logging.info('%-3s: %s -> %s' % (abbrev(cond), ', '.join(p), local_kl))
        total_kl += local_kl

    logging.info('total kl: %s', total_kl)
    return total_kl


def optimize():
    '''Find an optimal parameter setting to match human data.'''

    # compute mean looks across subjects for our target distributions.
    humans = HUMAN_LOOKS.mean(axis=1)
    logging.info('prepared human data %s', humans.shape)
    logging.info('mean look durations (speedo / leader):')
    bins = np.linspace(0, 30, 101)
    for cond, hum in zip(CONDITIONS, humans):
        logging.info('%-12s: %.2f / %.2f', cond,
                     sum(bins * hum[:, 0]) / hum[:, 0].sum(),
                     sum(bins * hum[:, 1]) / hum[:, 1].sum())

    logging.info('best params: %s', SO.fmin_powell(
        compare, (1, 1, 1, 0.1, 0.1, 0.1, 0.1, 0.1), args=(humans, )))


if __name__ == '__main__':
    lmj.cli.call(optimize)
